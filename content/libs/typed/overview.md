---
title: overview
weight: 1
---

# Overview

Here you will find an overview of {l:typed}: a library devoted to allow type safe constructions in Python.

```{toc}
```

# Overview: Types

The {l:typed} library introduces a new type system for Python. Everything begins with {l:universes}. These creates {l:universal metatypes}, which extends {l:abstract metatype}. These, in turn, create {l:types}, as follows:

```
          creates              extends              creates
UNIVERSE ────────>  UNIVERSAL ─────────> ABSTRACT  ─────────> TYPES
                    METATYPES            METATYPES
```

The {l:typed} type system is generated by a single {l:universe}, denoted by `__UNIVERSE__`, and by a single {l:universal metatype}, denoted by `_TYPE_`. So, every {l:abstract metatype} is a {p:subclass} of `_TYPE_`. In turn, `_TYPE_` creates a special {l:type} `TYPE` of which any other type is an {l:object}.

(notation-1)=
> [Notation](#notation-1). 
> 1. {l:abstract metatypes} are denoted in `UPPERCASE`
> 2. {l:types} are denoted in `CamelCase`.

What characterize an entity in the {l:typed} type system is their {l:objects}. We check if a symbol `x` is an {l:object} of an entity `Entity` with the expression `x in Entity`. Thus, for example, a symbol `SomeType`  is a {l:type} precisely if `SomeType in TYPE`.

Every Python builtin type has an incarnation as a {l:typed type}, which is created by a specific {l:abstract metatype}:

(table-1)=
```
Python builtin        typed type        metatype
-------------------------------------------------
type(None)            Nill              NILL
bool                  Bool              BOOL
int                   Int               INT
float                 Float             FLOAT
str                   Str               STR
...
--------------------------------------------------
python types _vs_ typed types
```

# Overview: Relations

The entities in the {l:typed} type system can be related in different ways. The basic way is in terms of a {l:typed function}. This is a {p:function} whose {p:parameters} have {p:type annotations} which are checked at runtime. They form a {l:type} `Typed`, of which the other type relations are {l:subtypes}, forming the following hierarchy:

```
                               extends
          extends            ┌────────> Operation
        ┌────────> Factory ──┤
Typed ──┤                    └────────> Dependent
        └────────> Condition   extends
         extends
```

1. A {l:type factory} is a {l:typed function} that constructs a {l:type}, hence that take values into `TYPE`.
2. In turn, a {l:condition} is a {l:typed function} that returns a boolean, i.e., that take values into `Bool`.
3. A {l:type operation} is a {l:type factory} such that all {p:type annotations} are {l:subtypes} of `TYPE`.
4. A {l:dependent type} is a special {l:type factory} with the attribute `.is_dependent_type` set to `True`. 

# Overview: Dependent Types

In a type system, dependent types are crucially important to provide a strong type expressiveness needed to ensure type safety. In {l:typed} they are implemented as {l:type factories} and can be passed as {p:type annotations} to any {l:typed function}.

This means that in {l:typed} one may have a relation between {l:types} such that the {l:type} of a {p:parameter} depends on the value of the other parameters.

# Overview: Models

One can say that a type system _presents type safety_ when each validation is realized as a type checking. This include data validation. Data, in turn, is typically presented in terms of hierarchical structure, as JSON. In {l:typed} one can deal with data validation by constructing parameterized subtypes of a `Json` type known as {l:models}.


