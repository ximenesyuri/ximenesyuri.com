---
title: overview
weight: 1
---

# Overview

Here you will find an overview of {lib:typed}: a library devoted to allow type safe constructions in Python.

```{toc}
```

# Overview: Types

The {lib:typed} library introduces a new type system for Python. Everything begins with {lib:universes}. These creates {lib:universal metatypes}, which extends {lib:abstract metatype}. These, in turn, create {lib:types}, as follows:

```
          creates              extends              creates
UNIVERSE ────────>  UNIVERSAL ─────────> ABSTRACT  ─────────> TYPES
                    METATYPES            METATYPES
```

The {lib:typed} type system is generated by a single {lib:universe}, denoted by `__UNIVERSE__`, and by a single {lib:universal metatype}, denoted by `_TYPE_`. So, every {lib:abstract metatype} is a {py:subclass} of `_TYPE_`. In turn, `_TYPE_` creates a special {lib:type} `TYPE` of which any other type is an {lib:object}.

(notation-1)=
> [Notation](#notation-1). 
> 1. {lib:abstract metatypes} are denoted in `UPPERCASE`
> 2. {lib:types} are denoted in `CamelCase`.

What characterize an entity in the {lib:typed} type system is their {lib:objects}. We check if a symbol `x` is an {lib:object} of an entity `Entity` with the expression `x in Entity`. Thus, for example, a symbol `SomeType`  is a {lib:type} precisely if `SomeType in TYPE`.

Every Python builtin type has an incarnation as a {lib:typed type}, which is created by a specific {lib:abstract metatype}:

(table-1)=
```
Python builtin        typed type        metatype
-------------------------------------------------
type(None)            Nill              NILL
bool                  Bool              BOOL
int                   Int               INT
float                 Float             FLOAT
str                   Str               STR
...
--------------------------------------------------
table 1: python types _vs_ typed types
```

# Overview: Relations

The entities in the {lib:typed} type system can be related in different ways. The basic way is in terms of a {lib:typed function}, which are {py:callable} entities. This is a {py:function} whose {py:parameters} have {py:type annotations} which are checked at runtime. They form a {lib:type} `Typed`, of which the other type relations are {lib:subtypes}, forming the following hierarchy:

```
                               extends
          extends            ┌────────> Operation
        ┌────────> Factory ──┤
Typed ──┤                    └────────> Dependent
        └────────> Condition   extends
         extends
```

1. A {lib:type factory} is a {lib:typed function} that constructs a {lib:type}, hence that take values into `TYPE`.
2. In turn, a {lib:condition} (a.k.a {lib:predicate}) is a {lib:typed function} that returns a boolean, i.e., that take values into `Bool`.
3. A {lib:type operation} is a {lib:type factory} such that all {py:type annotations} are {lib:subtypes} of `TYPE`.
4. A {lib:dependent type} is a special {lib:type factory} with the attribute `.is_dependent_type` set to `True`.

To each kind of relation there corresponds a decorator which should be used to create such a relation:

(table-2)=
```
relation        decorator 
-----------------------------
Typed           @typed
Factory         @factory
Condition       @condition
Operation       @operation
Dependent       @dependent
-----------------------------
table 2: relations and decorators
```

# Overview: Parametric Types

In {lib:typed} there are special mixed entities, which are both {lib:types} and type relations (more precisely, {lib:type factories} or {lib:type operations}). These are the so-called {lib:parametric types}.

An example is `Typed`. It is the {lib:type} of all {lib:typed functions}. It is also a {lib:type operation}: it can receive a tuple of types `(SomeType, OtherType, ...)` and another type `ReturnType`, returning the {lib:subtype} `Typed(SomeType, OtherType, ..., cod=ReturnType)` of `Typed` of all {lib:typed functions} whose {lib:domain} is  `(SomeType, OtherType, ...)` and whose {lib:codomain} is `ReturnType`.

# Overview: Dependent Types

In a type system, dependent types are crucially important to provide a strong type expressiveness needed to ensure type safety. In {lib:typed} they are implemented as {lib:type factories} and can be passed as {py:type annotations} to any {lib:typed function}.

This means that in {lib:typed} one may have a relation between {lib:types} such that the {lib:type} of a {py:parameter} depends on the value of the other {py:parameters}.

# Overview: Models

One can say that a type system _presents type safety_ when each validation is realized as a type checking. This include data validation. Data, in turn, is typically presented in terms of hierarchical structure, as JSON.  

In {lib:typed} one can deal with data validation by constructing parameterized {lib:subtypes} of a `Json` {lib:type} known as {lib:models}. These are constructed from certain {lib:type factories} known as {lib:model factories}. Different {lib:model factories} constructs {lib:models} with different kinds of validation and are constructed from specific {lib:abstract metatypes}.

(table-3)=
```
model factory      description                   metatype   
------------------------------------------------------------
Model              basic validation              MODEL
Exact              exact validation              EXACT
Ordered            order validation              ORDERED
Rigid              order and exact validation    RIGID
------------------------------------------------------------
table 3: model factories
```

# Other Docs

```{toc-dir}
```
